# BOJ 2000번 ~ 2999번 문제 풀이

## 📌 BOJ 2164 - 카드 2
- **문제 링크**: [백준 2164번](https://www.acmicpc.net/problem/2164)
- **풀이 요약**: 간단한 큐 사용법을 익히는 문제

## 📌 BOJ 2751 - 수 정렬하기 2
- **문제 링크**: [백준 2751번](https://www.acmicpc.net/problem/2751)
- **풀이 요약**: 시간 제한을 넘지 않는 게 중요했던 문제. BufferedReader, StringTokenize, StringBuilder 사용. 

## 📌 BOJ 2206 - 벽 부수고 이동하기 
- **문제 링크**: [백준 2206번](https://www.acmicpc.net/problem/2206)
- **풀이 요약**: 너비 우선 탐색을 적용
- **헤맸던 점**
  - 처음에는 벽을 부순 상태를 나타내는 boolean 타입의 flag를 사용하려 했으나 반복문 내에서 값을 할당하는 부분에서 예외가 발생했다.
  - 그래서 벽을 부수지 않았을 때와 벽을 부쉈을 때의 방문 여부를 기록하는 배열 2개를 이용해서, 벽을 부순 유무에 따라 다른 배열에 저장하게 했다.

## 📌 BOJ 2635 - 치즈
- **문제 링크**: [백준 2635번](https://www.acmicpc.net/problem/2638)
- **풀이 요약**: 외부 공기에 2면 이상 접촉해 녹는 치즈와 외부 + 내부 공기 2면 이상에 접촉하여 녹지 않는 치즈를 어떻게 구분할 지 하루 넘게 고민하다. 해답을 봤다.
  - 답은 생각보다 간단했다. BFS로 탐색하면서 외부 공기만 -1로 변경 + 방문처리 + 큐에 삽입. 반면에 치즈는 방문 처리만 한다.
  - 내부 공기는 치즈들(1)로 막혀있기 때문에 외부 BFS 탐색 중에 접근 자체가 불가능해진다.

## 📌 BOJ 2098 - 외판원 순회
- **문제 링크**: [백준 2098번](https://www.acmicpc.net/problem/2098)
- **풀이 요약**: Greedy 알고리즘으로는 구현은 쉽지만, 최적 경로가 보장되지 않는다. Brute-force 알고리즘은 시간이 오래 걸린다(O(N!)). 고로 외판원 순회 문제는 DP + 비트 마스킹으로 푸는 것이 핵심이다.(O(N * 2^n))
  - dpTable[도시][방문조합]: 방문 조합은 비트 마스킹으로 표시.
    - 0001 => 4개 도시 중 0번 도시 방문
    - 0011 => 4개 도시 중 0, 1번 도시 방문
    - 1001 => 4개 도시 중 0, 3번 도시 방문 ...
    - tsp의 if (visited == (1 << N) - 1)는 1110으로 출발 도시로 돌아가는 경로를 더하는 것만 남았음을 의미한다.
- **비슷한 유형 문제**
  - [외판원 순회 2](https://www.acmicpc.net/problem/10971)
  - [외판원 순회 3](https://www.acmicpc.net/problem/16991)
  - [우주 탐사선](https://www.acmicpc.net/problem/17182)
  - [발전소](https://www.acmicpc.net/problem/1102)
  - [임계경로](https://www.acmicpc.net/problem/1948)